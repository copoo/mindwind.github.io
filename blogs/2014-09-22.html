<!DOCTYPE html>
<html>
	<head>
		<meta charset='utf-8'>
	  	<meta http-equiv="X-UA-Compatible" content="chrome=1">
	  	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
	  	<link rel="stylesheet" href="/css/blog.css">
	  	<link rel="stylesheet" href="/css/code.css">
		<script type="text/javascript" src="/js/jquery-1.9.1.min.js"></script>
		<script type="text/javascript" src="/js/blog.js"></script>
		<script type="text/javascript" src="/js/ga.js"></script>
		<script type="text/javascript" src="/js/rainbow.js"></script>
		<script type="text/javascript" src="/js/rainbow.generic.js"></script>
		<script type="text/javascript" src="/js/rainbow.java.js"></script>
		
		<title>深入浅出 RPC - 深入篇</title>
	</head>

	<body>
		<div id="header" class="header"></div>
		
		<div id="center" class="center">
			<div id="content" class="content">
<span class="date">2014-09-22</span>
<h1>深入浅出 RPC - 深入篇</h1>
<img alt="" src="/blogs/2014-09-22.png" width="690">
<p>《深入篇》我们主要围绕 RPC 的功能目标和实现考量去展开，一个基本的 RPC 框架应该提供什么功能，满足什么要求以及如何去实现它？</p>

<h2>RPC 功能目标</h2>
<p>
<b>RPC 的主要功能目标是让构建分布式计算（应用）更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。</b>
为实现该目标，RPC 框架需提供一种透明调用机制让使用者不必显式的区分本地调用和远程调用，在前文《浅出篇》中给出了一种实现结构，基于 stub 的结构来实现。
下一节我们将具体细化 stub 结构的实现。
</p>

<h2>RPC 调用分类</h2>
<p>
RPC 调用分以下两种：
</p>
<pre><code>
<b>同步调用</b>
客户端等待调用执行完成并返回结果。
<b>异步调用</b>
客户端调用后不用等待执行结果返回，但依然可以通过回调通知等方式获取返回结果；若客户端不关心调用返回结果，则变成单向异步调用，单向调用不用返回结果。
</code></pre>
<p>异步和同步的区分在于是否等待服务端执行完成并返回结果。</p>

<h2>RPC 结构拆解</h2>
<p>
《浅出篇》给出了一个比较粗粒度的 RPC 实现概念结构，这里我们进一步细化它应该由哪些组件构成，如下图所示。
<a href="2014-09-22-1.svg" target="_blank"><img src="2014-09-22-1.svg" width="690"/></a><br>
</p>
<p>
RPC 服务方通过 <code>RpcServer</code> 去发布（export）远程接口方法，而客户方通过 <code>RpcClient</code> 去引入（import）远程接口方法。
客户方像调用本地方法一样去调用远程接口方法，RPC 框架提供接口的代理实现，实际的调用将委托给代理 <code>RpcProxy</code> 。
代理封装调用信息并将调用转交给 <code>RpcInvoker</code> 去实际执行。
在客户端的 <code>RpcInvoker</code> 使用 <code>RpcProtocol</code> 执行协议编码（encode），并通过连接器 <code>RpcConnector</code> 去维持与服务端的通道 <code>RpcChannel</code>，
通过通道去传输数据。
</p>
<p>
RPC 服务端接收器 <code>RpcAcceptor</code> 接收客户端的调用请求，同样使用<code>RpcProtocol</code> 执行协议解码（decode）。
解码后的调用信息传递给 <code>RpcProcessor</code> 去控制处理调用过程，最后再委托调用给 <code>RpcInvoker</code> 去实际执行并返回调用结果。
</p>

<h2>RPC 组件职责</h2>
<p>
上面我们进一步拆解了 RPC 实现结构的各个组件组成部分，下面我们详细说明下每个组件的职责划分。
</p>
<pre><code>
<b>RpcServer</b>
负责导出（export）远程接口
<b>RpcClient</b>
负责导入（import）远程接口的代理实现
<b>RpcProxy</b>
远程接口的代理实现
<b>RpcInvoker</b>
客户方实现：负责编码调用信息和发送调用到服务方并等待调用结果返回
服务方实现：负责调用服务端接口的具体实现并返回调用结果
<b>RpcProtocol</b>
负责协议编/解码
<b>RpcConnector</b>
负责维持客户方和服务方的连接通道和发送数据到服务方
<b>RpcAcceptor</b>
负责接收客户方请求并返回请求结果
<b>RpcProcessor</b>
负责在服务方控制调用过程，包括管理调用线程池、超时时间等
<b>RpcChannel</b>
数据传输通道
</code></pre>

<h2>RPC 实现分析</h2>
<p>
在进一步拆解了组件并划分了职责之后，这里以在 java 平台实现该 RPC 框架概念模型为例，详细分析下实现中需要考虑的因素。
</p>

<h3>导出远程接口</h3>
<p>
导出远程接口的意思是指只有导出的接口可以供远程调用，而未导出的接口则不能。
在 java 中导出接口的代码片段可能如下：
</p>
<pre><code data-language="java">
DemoService demo   = new ...;
RpcServer   server = new ...;
server.export(DemoService.class, demo, options);
</code></pre>
<p>我们可以导出整个接口，也可以更细粒度一点只导出接口中的某些方法，如：</p>
<pre><code data-language="java">
// 只导出 DemoService 中签名为 hi(String s) 的方法
server.export(DemoService.class, demo, "hi", new Class&lt;?&gt;[] { String.class }, options);
</code></pre>
<p>
java 中还有一种比较特殊的调用就是多态，也就是一个接口可能有多个实现，那么远程调用时到底调用哪个？
这个本地调用的语义时通过 jvm 提供的引用多态性隐式实现的，那么对于 RPC 来说时跨进程调用就没法隐式实现了。
如果前面 <code>DemoService</code> 接口有 2 个实现，那么在导出接口时就需要特殊标记不同的实现，如：
</p>
<pre><code data-language="java">
DemoService demo   = new ...;
DemoService demo2  = new ...;
RpcServer   server = new ...;
server.export(DemoService.class, demo, options);
server.export("demo2", DemoService.class, demo2, options);
</code></pre>
<p>上面 demo2 是另一个实现，我们标记为 "demo2" 来导出，远程调用时也需要传递该标记才能调用到正确的实现类。</p>

<h3>导入远程接口与客户端代理</h3>
<p>
导入相对于导出远程接口，客户端代码为了能够发起调用必须要获得远程接口的方法或过程定义。
目前，大部分跨语言平台 RPC 框架采用根据 IDL 定义通过 code generator 去生成 stub 代码，这种方式下实际导入的过程就是通过代码生成器在编译期完成的。
我所使用过的一些跨语言平台 RPC 框架，CORBAR、WebService、ICE、Thrift 均是此类方式。
</p>
<p>
代码生成的方式对跨语言平台 RPC 框架而言是必然的选择，而对于同一语言平台的 RPC 则可以通过共享接口定义来实现。
在 java 中导入接口的代码片段可能如下：
</p>
<pre><code data-language="java">
RpcClient client = new ...;
DemoService demo = client.refer(DemoService.class);
demo.hi("how are you?");
</code></pre>
<p>
在 java 中 'import' 是关键字，所以代码片段中我们用 refer 来表达导入接口的意思。
这里的导入方式本质也是一种代码生成技术，只不过是在运行时生成，看起来比静态编译期的代码生成看起来更简洁些。
java 里至少提供了两种技术来提供动态代码生成，一种是 jdk 动态代理，另外一种是字节码生成。
动态代理相比字节码生成使用起来更方便，但动态代理方式在性能上是要逊色与直接的字节码生成的，而字节码生成在代码可读性上要差很多。
两者权衡起来，个人认为牺牲一些性能来获得代码可读性和可维护性显得更重要。
</p>

<h3>协议编解码</h3>
<p>
客户端代理在发起调用前需要对调用信息进行编码，这就要考虑需要编码些什么信息并以什么格式传输到服务端才能让服务端完成调用。
出于效率考虑，自然编码的信息越少越好（传输数据少），编码的规则越简单越好（执行效率高）。
我们先看下需要编码些什么信息：
</p>
<pre><code>
-- 调用编码 --
<b>接口方法</b>
包括接口名、方法名
<b>方法参数</b>
包括参数类型、参数值
<b>调用属性</b>
包括调用属性信息，例如调用附件隐式参数、调用超时时间等

-- 返回编码 --
<b>返回结果</b>
接口方法中定义的返回值
<b>返回码</b>
异常返回码
<b>返回异常信息</b>
调用异常信息
</code></pre>
<p>
除了以上这些必须的调用信息，我们可能还需要一些元信息以方便程序编解码以及未来可能的扩展。
这样我们的编码消息里面就分成了两部分，一部分是元信息、另一部分是调用的必要信息。
如果设计一种 RPC 协议消息的话，元信息我们把它放在协议消息头中，而必要信息放在协议消息体中。
下面给出一种概念上的 RPC 协议消息设计格式：
</p>
<pre><code>
-- 消息头 --
<a href="2014-09-22-2.png" target="_blank"><img src="2014-09-22-2.png" width="690"/></a>
magic      : 协议魔数，为解码设计
header size: 协议头长度，为扩展设计
version    : 协议版本，为兼容设计
st         : 消息体序列化类型
hb         : 心跳消息标记，为长连接传输层心跳设计
ow         : 单向消息标记，
rp         : 响应消息标记，不置位默认是请求消息
status code: 响应消息状态码
reserved   : 为字节对齐保留
message id : 消息 id
body size  : 消息体长度

-- 消息体 --
采用序列化编码，常见有以下格式
xml   : 如 webservie soap
json  : 如 JSON-RPC
binary: 如 thrift; hession; kryo 等
</code></pre>
<p>
格式确定后编解码就简单了，由于头长度一定所以我们比较关心的就是消息体的序列化方式。
序列化我们关系三个方面：<br>
<br>
1. 序列化和反序列化的效率，越快越好。 <br>
2. 序列化后的字节长度，越小越好。 <br>
3. 序列化和反序列化的兼容性，接口参数对象若增加了字段，是否兼容。<br>
<br>
上面这三点有时是鱼与熊掌不可兼得，这里面涉及到具体的序列化库实现细节，就不在本文进一步展开分析了。
</p>

<h3>传输服务</h3>
<p>
协议编码之后，自然就是需要将编码后的 RPC 请求消息传输到服务方，服务方执行后返回结果消息或确认消息给客户方。
RPC 的应用场景实质是一种可靠的请求应答消息流，和 HTTP 类似。
因此选择长连接方式的 TCP 协议会更高效，与 HTTP 不同的是在协议层面我们定义每个消息的唯一 id，因此可以更容易的复用连接。
</p>
<p>
既然使用长连接，那么第一个问题是到底 client 和 server 之间需要多少根连接？
实际上单连接和多连接在使用上没有区别，对于数据传输量较小的应用类型，单连接基本足够。
单连接和多连接最大的区别在于，每根连接都有自己私有的发送和接收缓冲区，因此大数据量传输时分散在不同的连接缓冲区会得到更好的吞吐效率。
所以，如果你的数据传输量不足以让单连接的缓冲区一直处于饱和状态的话，那么使用多连接并不会产生任何明显的提升，反而会增加连接管理的开销。
</p>
<p>
连接是由 client 端发起建立并维持。
如果 client 和 server 之间是直连的，那么连接一般不会中断（当然物理链路故障除外）。
如果 client 和 server 连接经过一些负载中转设备，有可能连接一段时间不活跃时会被这些中间设备中断。
为了保持连接有必要定时为每个连接发送心跳数据以维持连接不中断。
心跳消息是 RPC 框架库使用的内部消息，在前文协议头结构中也有一个专门的心跳位，就是用来标记心跳消息的，它对业务应用透明。
</p>
			</div>
			<div id="aside"></div>
		</div>
		
		<div id="footer" class="footer"></div>
	</body>
</html>

