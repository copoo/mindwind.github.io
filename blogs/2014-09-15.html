<!DOCTYPE html>
<html>
	<head>
		<meta charset='utf-8'>
	  	<meta http-equiv="X-UA-Compatible" content="chrome=1">
	  	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
	  	<link rel="stylesheet" href="/css/blog.css">
		<script type="text/javascript" src="/js/jquery-1.9.1.min.js"></script>
		<script type="text/javascript" src="/js/blog.js"></script>
		<script type="text/javascript" src="/js/ga.js"></script>
		
		<title>深入浅出 RPC - 浅出篇</title>
	</head>

	<body>
		<div id="header" class="header"></div>
		
		<div id="center" class="center">
			<div id="content" class="content">
<span class="date">2014-09-15</span>
<h1>深入浅出 RPC - 浅出篇</h1>
<img alt="" src="/blogs/2014-09-15.jpg" width="690">

<p>
近几年的项目中，服务化和微服务化渐渐成为中大型分布式系统架构的主流方式，而 RPC 在其中扮演着关键的作用。
在平时的日常开发中我们都在隐式或显式的使用 RPC，一些刚入行的程序员会感觉 RPC 比较神秘，而一些有多年使用 RPC 经验的程序员虽然使用经验丰富，但有些对其原理也不甚了了。
缺乏对原理层面的理解，往往也会造成开发中的一些误用，本文的目标就是想尝试深入浅出的分析下 RPC 本质，余总是这么认为理解了本质才能更好的应用。
</p>

<h2>RPC 是什么？</h2>
<p>
RPC 的全称是 Remote Procedure Call 是一种进程间通信方式。
它允许程序调用另一个地址空间（通常共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。
即程序员无论是调用本地的还是远程的，本质上编写的调用代码基本相同。
</p>

<h2>RPC 起源</h2>
<p>
RPC 这个概念术语在上世纪 80 年代由 <a href="https://en.wikipedia.org/wiki/Bruce_Jay_Nelson" target="_blank">Bruce Jay Nelson</a> 提出。
这里我们追溯下当初开发 RPC 的原动机是什么？
在 Nelson 的论文 <a href="http://birrell.org/andrew/papers/ImplementingRPC.pdf" target="_target">"Implementing Remote Procedure Calls"</a> 中他提到了几点：<br>
</p>
<blockquote>
1. 简单：RPC 概念的语义十分清晰和简单，这样建立分布式计算就更容易。<br>
2. 高效：过程调用看起来十分简单而且高效。<br>
3. 通用：在单机计算中过程往往是不同算法部分间最重要的通信机制。 <br>
</blockquote>
<p>
通俗一点说，就是一般程序员对于本地的过程调用很熟悉，那么我们把 RPC 作成和本地调用完全类似，那么就更容易被接受，使用起来毫无障碍。
Nelson 的论文发表于 30 年前，其观点今天看来确实高瞻远瞩，今天我们使用的 RPC 实现基本就是按这个目标来实现的。
</p>

<h2>RPC 结构</h2>
<p>
Nelson 的论文中指出实现 RPC 的程序包括 5 个部分：
</p>
<blockquote>
1. User<br>
2. User-stub<br>
3. RPCRuntime<br>
4. Server-stub<br>
5. Server<br>
</blockquote>
<p>
这 5 个部分的关系如下图所示<br>
<a href="2014-09-15-1.png" target="_blank"><img src="2014-09-15-1.png" /></a><br>
这里 user 就是 client 端，当 user 想发起一个远程调用时，它实际是通过本地调用 user-stub。
user-stub 负责将调用的接口、方法和参数通过约定的协议规范进行编码并通过本地的 RPCRuntime 实例传输到远端的实例。
远端 RPCRuntime 实例收到请求后交给 server-stub 进行解码后发起本地端调用，调用结果再返回给 user 端。
</p>

<h2>RPC 实现</h2>
<p>
Nelson 论文中给出的这个实现结构也成为后来大家参考的标准范本。
大约 10 年前，我最早接触分布式计算时使用的 <a href="https://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture" target="_blank">CORBAR</a> 实现结构基本与此类似。
</p>

			</div>
			<div id="aside"></div>
		</div>
		
		<div id="footer" class="footer"></div>
	</body>
</html>

