<!DOCTYPE html>
<html>
	<head>
		<meta charset='utf-8'>
	  	<meta http-equiv="X-UA-Compatible" content="chrome=1">
	  	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
	  	<link rel="stylesheet" href="/css/blog.css">
		<link rel="icon" href="favicon.ico" mce_href="favicon.ico" type="image/x-icon">
		<script type="text/javascript" src="/js/jquery-1.9.1.min.js"></script>
		<script type="text/javascript" src="/js/blog.js"></script>
		<script type="text/javascript" src="/js/ga.js"></script>
		
		<title>程序员的视角：java 线程</title>
	</head>

	<body>
		<div id="header" class="header"></div>
		
		<div id="center" class="center">
			<div id="content" class="content">
<span class="date">2014-03-30</span>
<h1>程序员的视角：java 线程</h1>
<img alt="" src="/blogs/2014-03-30.jpg">

<p>
在我们开始谈线程之前，不得不提下进程。<br>
无论进程还是线程都是很抽象的概念，有一个关于进程和线程很形象的比喻帮我们更好的理解。
</p>
<blockquote>
进程就像个房子，房子是一个包含了特定属性的容器，例如空间大小、卧室数量等。
如果你也这样看的话，那么房子自己不会主动做任何事情，它是被动的对象。
而线程则像是房中的居住者，它是主动的对象——居住者要使用不同的房间、看电视、煮饭、洗澡等等。
房子占据着一块真实的土地，正像进程占据着内存。
而房子的居住者可以自由出入所有的房间，而进程中的线程也是类似的，可以自由访问任何进程占据的内存。
</blockquote>
<p>
按照教科书上的定义，进程是资源管理的最小单位，线程是程序执行的最小单位。
通过上面的比喻，我们可以更容易的理解进程和线程的关系。
进程只是一个容器对象，它负责占据资源（内存地址、文件I/O），而线程共享进程的资源，作为CPU调度的基本单位可以被独立调度。
</p>

<h3>线程实现</h3>
<p>
回到我们的题目：java 线程。
java 作为一个跨平台的语言，自然要提供一个跨平台的线程实现。
线程按类型可以分为内核线程和用户线程，分类的标准主要是线程的调度者在核内还是在核外。
早期时，一些操作系统因为没有提供线程的原生实现，所以早在JDK1.2之前，java是基于用户线程来实现的。
用户线程是相对内核线程而言，内核线程自然是由操作系统内核支持的线程，由内核来管理和调度。
后来主流操作系统都支持了线程，因此现在java都采用原生线程来实现了。
</p>
<p>
既然现在的java线程都采用原生系统线程来实现，那么是否每个java线程就对应一个系统内核线程？
对Sun JDK而言，在Windows和Linux中都是采用的一对一模型，Linux提供一种称为轻量级进程（LWP）的高级抽象来避免应用直接使用内核线程。
而在像Solaris这样的系统中则不一定了，因为它支持多对多模型。
不过对于底层系统的线程模型到底如何，对java线程而言都是被屏蔽了的，JVM层面提供了一个统一的抽象线程模型。
</p>

<h3>线程状态</h3>
<p>
java定义了6种线程状态，任一时刻一个线程处于其中一种状态，其状态转换关系如下图：<br>
<a href="2014-03-30-1.png" target="_blank"><img src="2014-03-30-1.png" /></a>
</p>
<pre><code>
1. <a>NEW</a>
   新创建未启动的线程处于该状态
2. <a>RUNNABLE</a>
   调用了start()方法后，线程进入RUNNABLE状态
3. <a>WAITING</a>
   不设置timeout的Object.wati()、Thread.join()等方法会让线程进入无限等待，需要等待其他线程显式的唤醒。
4. <a>TIMED_WAITING</a>
   Thead.sleep()或设置了timeout的Object.wati()、Thread.join()等方法让线程进入限期等待。
5. <a>BLOCKED</a>
   阻塞状态，线程在等待进入同步区域。
6. <a>TERMINATED</a>
   线程执行结束，终止状态。
</code></pre>
<p>
从上面的状态图可以看出，线程从新建、执行到结束是单向的，期间可能会经历等待和阻塞状态，线程执行结束进入终止状态后将不能再重复使用。
任何时候一个CPU核只能执行一个线程，也就是说同时并行运行的线程数与CPU核数相等。
在操作系统内核层面，线程只有分配了CPU的执行时间片，才算处于<code>RUNNING</code>状态。
而当有大于CPU核数的线程需要执行，没有分配到CPU执行时间片的线程则处于<code>READY</code>状态。
<code>RUNNING</code>和<code>READY</code>都是线程在内核的状态，同时映射到java的<code>RUNNABLE</code>状态。
<code>RUNNABLE</code>正如其名，表示可运行的状态，并非正在运行的状态。
</p>
			</div>
			<div id="aside"></div>
		</div>
		
		<div id="footer" class="footer"></div>
	</body>
</html>

