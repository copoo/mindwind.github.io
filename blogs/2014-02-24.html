<!DOCTYPE html>
<html>
	<head>
		<meta charset='utf-8'>
	  	<meta http-equiv="X-UA-Compatible" content="chrome=1">
	  	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
	  	<link rel="stylesheet" href="/css/default.css">
		<link rel="icon" href="favicon.ico" mce_href="favicon.ico" type="image/x-icon">
		<script type="text/javascript" src="/js/jquery-1.9.1.min.js"></script>
		<script type="text/javascript" src="/js/default.js"></script>
		<script type="text/javascript" src="/js/ga.js"></script>
		
		<title>程序员的视角：java GC</title>
	</head>

	<body>
		<div id="header" class="header"></div>
		
		<div id="center" class="center">
			<div id="content" class="content">
				<h1>程序员的视角：java GC</h1>
				<span class="date">2014-02-24</span>
				<div class="divider"></div>
				
				
				<p>
					GC（Garbage Collection 垃圾回收）的概念随着 java 的流行而被人们所熟知。
					实际 GC 最早起源于20世纪60年代的 LISP 语言，是一种自动的内存管理机制。
					GC 要解决的问题有 3 个：<br>
					1. 回收什么？（what）<br>
					2. 何时回收？（when）<br>
					3. 如何回收？（how）<br>
				</p>
				
				
				<h3>回收什么？</h3>
				<p>
					清理的是垃圾，回收的是内存空间。<br>
					既然 GC 是 java 的自动内存管理机制，那么先看下 java 虚拟机将所管理的内存划分为不同的区域，如图1。
					<a href="2014-02-24-1.png" target="_blank"><img src="2014-02-24-1.png" width="700"></a>
				</p>
				<p>
					如图1所示，java 虚拟机管理的内存区域分为如下几个部分：<br>
					1. 堆（Heap） <br>
					2. 方法区（Method Area）<br>
					3. 虚拟机栈（VM Stack）<br>
					4. 本地方法栈（Native Method Stack）<br>
					5. 程序计数器（Program Counter Register）<br>
					其中堆和方法区属于所有线程共享，而其他区域属于线程隔离的区域。<br>
					下面我们以 java HotSpot 虚拟机为例分别说说每个区域的作用和构成：
				</p>
				<p>
					<b>堆（Heap）</b><br>
					堆用于存储对象实例，从内存回收的角度看，由于收集器基本都采用了分代收集算法，所以堆可以进一步细分为：<br>
					- Eden 区<br>
					- Survivor 0 区 （From）<br>
					- Survivor 1 区 （To）<br>
					- Old/Tenured 区<br>
					其中 Eden、S0、S1 组成了新生代（Young/New Generation），Old/Tenured 为老年代。
				</p>
				<p>
					<b>方法区（Method Area）</b><br>
					方法区存储虚拟机加载的类信息、常量、编译代码等数据。
					HotSpot 虚拟机使用永久代（Permanent Generation）来实现方法区。
				</p>
				<p>
					<b>虚拟机栈（VM Stack）</b><br>
					虚拟机栈描述的是 java 方法执行的内存模型，每个方法在执行时创建一个栈帧（Stack Frame）。
					栈帧中存储内容主要包含：<br>
					- 局部变量表<br>
					- 操作数栈<br>
					- 动态链接<br>
					- 方法返回地址<br>
					每个方法的执行过程就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
				</p>
				<p>
					<b>本地方法栈（Native Method Stack）</b><br>
					本地方法栈与虚拟机栈类似，只不过服务于虚拟机执行 Native 方法时。
					HotSpot 虚拟机的实现把虚拟机栈和本地方法栈合二为一。
				</p>
				<p>
					<b>程序计数器（Program Counter Register）</b><br>
					可以看作是线程执行的字节码的行号指示器，在虚拟机的概念模型中便于实现分支、循环、跳转、异常处理和线程切换恢复等基础功能。
					每个线程都有一个独立的程序计数器。
				</p>
				<p>
					GC 管理的内存区域主要是堆（Heap），而堆中存放的是对象实例，因此 GC 回收的就是“死亡”（不可能再被使用）的对象占用的内存空间。
				</p>
				
				
				<h3>何时回收？</h3>
				<p>
					既然说到“死亡”的对象，那不得不说下对象的生命周期。<br>
					虚拟机通过 new 指令创建了对象，大多数对象创建时在 Eden 区分配内存空间，而一些大对象若 Eden 区不能满足其空间需求时会直接在 Old/Tenured 区分配。<br>
					对象的死亡判定，主流的 GC 实现都是通过可达性分析，形象点来说就是在基于引用建立的对象图中形成了孤岛的对象就是死亡的（可回收的）。
				</p>
				<p>
					<b>GC 分类</b><br>
					- Minor GC<br>
					- Major GC<br>
					- Full  GC<br>
					Minor GC 是针对新生代的回收，当 Eden 区空间满了时将触发 Minor GC。<br>
					Major GC 是针对老年代的回收，当 Minor GC 发生时会拷贝对象到老年代，这个过程称为对象晋升（promotion）或老年化（tenuring），细节我们后文再讲。<br>
					为了避免对象晋升时老年代空间不足，收集器总是尝试预测剩余的空间是否足够以避免对象晋升失败，当晋升失败时就会发生 Full GC。<br>
					Full  GC 是针对整个堆的操作，是非常昂贵的操作。除了在对象晋升失败时发生 Full GC，当堆自动调整大小时（Heap-Resizing）也会发生，不过可以通过设置
					<code>-Xms</code>和<code>-Xmx</code>为相同的值来避免 Heap-Resizing。
				</p>
				
				
				<h3>如何回收？</h3>
				<p>
					Minor GC 将新生代中存活的对象拷贝到 Survivor 区和 Tenured 区。<br>
					Major GC 针对老年代区域进行死亡对象标记、清除和内存整理。<br>
					Full  GC 则包括了所有存活对象的晋升以及老年代的内存回收及整理。<br>
				</p>
			</div>
			<div id="aside"></div>
		</div>
		
		<div id="footer" class="footer"></div>
	</body>
</html>

