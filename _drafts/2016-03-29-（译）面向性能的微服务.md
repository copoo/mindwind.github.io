---
layout    : post
title     : （译）面向性能的微服务
date      : 2016-03-29
author    : mindwind
categories: blog
tags      : 微服务 性能
image     : /assets/article_images/2016-03-23.jpg
elapse    : 2h20
---


## 摘要


## 正文


### Overview  概述  
Microservices is a buzz word at the moment. Is it really something original or based on established best practices. There are some disadvantages to the way micro-services have been implemented, but can these be solved?
微服务是目前的一个热门词汇。它是原创的还是基于最佳实践产生的？虽然在实施微服务的过程中有一些缺点，但这些缺点能被克服么？


### Component testability and consistency  组件可测试性和稳定性
Once you have assembled a large system, it can be hard to impossible to profile where the highest delays come from. You can profile for average latency or throughput, but to achieve consistent latencies, you need to analyse key portions of your system. This is where having simple components which run independently and be tested stand alone can help you achieve the the consistency of your system needs end to end.
一旦你组装好了一个大系统，那么几乎不可能监测到系统的最大延迟来自哪里。你可以监测到平均的延迟和吞吐量，但为了达到稳定的延迟，需要去分析系统的关键部分。这正是一个由简单组件构成并且独立运行和测试的系统可以帮到你的地方，它能帮你实现系统端到端的延迟稳定性。


### The UNIX Philosophy  UNIX 哲学
Many of the key concepts of Micro-services have been used in distributed systems for many years.
Micro-services have much in common with the Unix Philosophy.
微服务中的许多关键概念已经在分布式系统中使用多年了。它与[Unix哲学](https://en.wikipedia.org/wiki/Unix_philosophy)有很多共同之处。

Mike Gancarz is quoted as summed these principles as follows

 - Small is beautiful.
 - Make each program do one thing well.
 - Build a prototype as soon as possible.
 - Choose portability over efficiency.
 - Store data in flat text files.
 - Use software leverage to your advantage.
 - Use shell scripts to increase leverage and portability.
 - Avoid captive user interfaces.
 - Make every program a filter.

引用[Mike Gancarz](https://en.wikipedia.org/wiki/Unix_philosophy#Mike_Gancarz:_The_UNIX_Philosophy)总结的这些原则，如下所示：

 > - 小即是美。
 > - 一个程序只做好一件事。
 > - 尽可能早地创建原型
 > - 可移植性比效率更重要。
 > - 数据应该保存为文本文件。
 > - 尽可能地榨取软件的全部价值。
 > - 使用shell脚本来提高效率和可移植性。
 > - 避免使用可定制性低下的用户界面。
 > - 所有程序都是数据的过滤器。

The Microservices Architecture is the UNIX Philosophy applied to distributed systems.

 > Philosophy of microservices architecture essentially equals the Unix philosophy of "Do one thing and do it   well". It is described as follows:
 > - The services are small - fine-grained to perform a single function.
 > - The organization culture should embrace automation of deployment and testing. This eases the burden on   management and operations.
 > - The culture and design principles should embrace failure and faults, similar to anti-fragile systems.
 > - Each service is elastic, resilient, composable, minimal, and complete.

[微服务](https://en.wikipedia.org/wiki/Microservices#Philosophy)即是把UNIX哲学应用到分布式系统。
 > 微服务架构哲学与UNIX哲学中“一次做好一件事”本质上是相同的。它描述如下：
 > - 服务小且细粒度的，完成单一功能。
 > - 企业文化应拥抱部署和测试自动化。这减轻了管理与运维负担。
 > - 文化和设计原则应接受失败和错误，类似于高容错性系统。
 > - 每个服务都是有弹性的，易恢复的，可组合的，最小化且完备的。

There are disadvantages to using a micro-services arhictecture some of which are

  > - services form information barriers
  > - the architecture introduces additional complexity and new problems to deal with, such as network latency, message formats, load balancing and fault tolerance,[15] ignoring one of these belongs to the "fallacies of distributed computing"
  > - testing and deployment are more complicated
  > - the complexity of a monolithic application is only shifted into the network, but persists.
  > - Too-fine-grained microservices have been criticized as an anti-pattern

使用微服务架构有一些[缺点](https://en.wikipedia.org/wiki/Microservices#Criticism)，如下：
  > - 服务带来信息障碍。
  > - 该架构引入了额外的复杂性和需要处理的新问题，如网络延迟、消息格式、负载均衡和容错，忽略其中任何一点都属于对“分布式计算的误解”。
  > - 测试和部署变得更复杂了。
  > - 单体应用的复杂性仅仅转移到了服务的网状分布中，但是依然存在。
  > - 过于细粒度的微服务已经被批评是反模式。

Can we get the best features of a monolith, and micro-services? Does it have to be one or the other? Should we not use the approach which best suits our problem. One of the key aspects of Micro-services is controlled deployment of an application. In which case, shouldn’t we be able to deploy components as a Monolith or Micro-services where it makes the most sense to do so.

 > Proposed alternatives to nanoservices include
 > - Package the functionality as a library, rather than a service.
 > - Combine the functionality with other functionality, producing a more substantial, useful service.
 > - Refactor the system, putting the functionality in other services or redesigning the system.

我们能得到单体应用和微服务都有的最佳特性吗？还是只能二选一？难道我们不该使用最适合我们问题的方法么？微服务的关键方面之一是控制应用的部署。在哪些情况下，我们不应该把一个组件部署为一个单独应用或微服务，这样对我们最有意义。

 > 对于超微服务的建议替代方案包括：
 > - 将功能打包为一个库而非服务。
 > - 和其他功能组合产生一个更有实质意义和有用的服务。
 > - 重构系统，将功能放在其他服务里或者重新设计系统。


### How can we get the best of both worlds?  我们怎样才能两全其美？
### Make your components composable  让组件可组合


## 来源
原文：[Micro-services for performance](https://vanilla-java.github.io/2016/03/22/Micro-services-for-performance.html)   
作者：[Peter Lawrey](http://vanillajava.blogspot.com/)
日期：2016/03/22  

---

写点文字，画点画儿，「瞬息之间」一切都变了。觉得不错，可长按或扫描二维码关注。
![](/assets/images/qrcode_wechat_avatar.jpg)
